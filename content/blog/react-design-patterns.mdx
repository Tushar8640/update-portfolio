---
title: "React Design Patterns: The Complete Guide"
date: "2026-01-29"
description: "Master essential React design patterns with real-world examples. From HOCs to Render Props to modern hooks patterns."
tags: ["react", "patterns", "design-patterns", "advanced"]
published: true
---

Design patterns are proven solutions to common problems. Let's explore the most important React patterns you'll use in production.

## 1. Higher-Order Components (HOC)

A function that takes a component and returns a new component with enhanced functionality.

### When to Use
- Adding common behavior to multiple components
- Code reuse across components
- Conditional rendering logic

### Example: Authentication HOC

```tsx
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const { user, isLoading } = useAuth();

    if (isLoading) return <Spinner />;
    if (!user) return <Navigate to="/login" />;

    return <Component {...props} user={user} />;
  };
}

// Usage
const Dashboard = ({ user }) => <div>Welcome {user.name}</div>;
const ProtectedDashboard = withAuth(Dashboard);
```

### Example: Logging HOC

```tsx
function withLogging(Component, componentName) {
  return function LoggedComponent(props) {
    useEffect(() => {
      console.log(`${componentName} mounted`);
      return () => console.log(`${componentName} unmounted`);
    }, []);

    return <Component {...props} />;
  };
}

const UserProfile = withLogging(Profile, 'UserProfile');
```

## 2. Render Props Pattern

Share code between components using a prop whose value is a function.

### Example: Mouse Tracker

```tsx
function Mouse({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}

// Usage
function App() {
  return (
    <Mouse
      render={({ x, y }) => (
        <div>
          Mouse at: {x}, {y}
        </div>
      )}
    />
  );
}
```

### Example: Data Fetcher

```tsx
function DataFetcher({ url, render }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(url)
      .then(r => r.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return render({ data, loading });
}

// Usage
<DataFetcher
  url="/api/users"
  render={({ data, loading }) => (
    loading ? <Spinner /> : <UserList users={data} />
  )}
/>
```

## 3. Custom Hooks Pattern (Modern Approach)

The modern way to share stateful logic. Replace most HOCs and Render Props.

### Example: Form Hook

```tsx
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  };

  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
  };

  const validate = (validationRules) => {
    const newErrors = {};
    Object.keys(validationRules).forEach(field => {
      const error = validationRules[field](values[field]);
      if (error) newErrors[field] = error;
    });
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    validate
  };
}

// Usage
function LoginForm() {
  const form = useForm({ email: '', password: '' });

  const handleSubmit = (e) => {
    e.preventDefault();
    const isValid = form.validate({
      email: (v) => !v ? 'Required' : null,
      password: (v) => v.length < 6 ? 'Too short' : null
    });

    if (isValid) {
      // Submit form
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        value={form.values.email}
        onChange={form.handleChange}
        onBlur={form.handleBlur}
      />
      {form.touched.email && form.errors.email && (
        <span>{form.errors.email}</span>
      )}
    </form>
  );
}
```

## 4. Compound Components Pattern

Components that work together to form a complete UI.

### Example: Tabs Component

```tsx
const TabsContext = createContext();

function Tabs({ children, defaultValue }) {
  const [activeTab, setActiveTab] = useState(defaultValue);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === value;

  return (
    <button
      className={isActive ? 'tab active' : 'tab'}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  if (activeTab !== value) return null;
  return <div className="tab-panel">{children}</div>;
}

// Export as compound component
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage
<Tabs defaultValue="home">
  <Tabs.List>
    <Tabs.Tab value="home">Home</Tabs.Tab>
    <Tabs.Tab value="profile">Profile</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panel value="home">Home Content</Tabs.Panel>
  <Tabs.Panel value="profile">Profile Content</Tabs.Panel>
</Tabs>
```

## 5. Provider Pattern

Share global data without prop drilling.

```tsx
// Create context
const UserContext = createContext();

// Provider component
export function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  const login = async (credentials) => {
    const userData = await api.login(credentials);
    setUser(userData);
  };

  const logout = () => setUser(null);

  return (
    <UserContext.Provider value={{ user, login, logout }}>
      {children}
    </UserContext.Provider>
  );
}

// Custom hook for easy access
export function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

// Usage
function App() {
  return (
    <UserProvider>
      <Header />
      <MainContent />
    </UserProvider>
  );
}

function Header() {
  const { user, logout } = useUser();
  return <div>{user?.name} <button onClick={logout}>Logout</button></div>;
}
```

## 6. Container/Presenter Pattern

Separate data logic from UI.

```tsx
// Container (logic)
function UserListContainer() {
  const { data: users, isLoading, error } = useQuery('users', fetchUsers);
  const { mutate: deleteUser } = useMutation(deleteUserApi);

  if (isLoading) return <Spinner />;
  if (error) return <Error message={error.message} />;

  return (
    <UserListPresenter 
      users={users} 
      onDelete={deleteUser}
    />
  );
}

// Presenter (UI)
function UserListPresenter({ users, onDelete }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => onDelete(user.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

## 7. State Reducer Pattern

Give users control over component state.

```tsx
function useToggle(initialState = false, reducer = (state, action) => action) {
  const [state, dispatch] = useReducer(reducer, initialState);

  const toggle = () => dispatch(!state);
  const setOn = () => dispatch(true);
  const setOff = () => dispatch(false);

  return { state, toggle, setOn, setOff };
}

// Custom reducer to add logging
function loggingReducer(state, action) {
  console.log('State:', state, 'Action:', action);
  return action;
}

// Usage
function Component() {
  const { state, toggle } = useToggle(false, loggingReducer);
  
  return (
    <button onClick={toggle}>
      {state ? 'On' : 'Off'}
    </button>
  );
}
```

## 8. Controlled vs Uncontrolled Pattern

### Controlled Component

```tsx
function ControlledInput() {
  const [value, setValue] = useState('');

  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}
```

### Uncontrolled Component

```tsx
function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    console.log(inputRef.current.value);
  };

  return (
    <>
      <input ref={inputRef} defaultValue="initial" />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
```

## 9. Portal Pattern

Render children outside parent DOM hierarchy.

```tsx
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;

  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    document.getElementById('modal-root')
  );
}

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      <Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>
        <h2>Modal Content</h2>
      </Modal>
    </>
  );
}
```

## 10. Lazy Loading Pattern

Load components on demand.

```tsx
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<Spinner />}>
      <HeavyComponent />
    </Suspense>
  );
}

// With error boundary
<ErrorBoundary>
  <Suspense fallback={<Spinner />}>
    <HeavyComponent />
  </Suspense>
</ErrorBoundary>
```

## When to Use Each Pattern

| Pattern | Use When | Avoid When |
|---------|----------|------------|
| HOC | Adding same behavior to many components | Complex prop manipulation needed |
| Render Props | Need flexibility in rendering | Custom hooks can solve it |
| Custom Hooks | Sharing stateful logic | Just sharing UI |
| Compound Components | Components work as a unit | Independent components |
| Provider | Global state needed | Local state is enough |
| Container/Presenter | Complex data fetching | Simple components |

## Anti-Patterns to Avoid

### ❌ Prop Drilling

```tsx
// Bad
<App>
  <Header user={user} />
    <Nav user={user} />
      <UserMenu user={user} />
```

### ✅ Use Context

```tsx
// Good
<UserProvider>
  <App />
</UserProvider>
```

### ❌ Derived State

```tsx
// Bad
const [data, setData] = useState([]);
const [filteredData, setFilteredData] = useState([]);

useEffect(() => {
  setFilteredData(data.filter(...));
}, [data]);
```

### ✅ Calculate on Render

```tsx
// Good
const [data, setData] = useState([]);
const filteredData = useMemo(() => 
  data.filter(...), 
  [data]
);
```

## Conclusion

Patterns are tools, not rules. Choose based on:
- Problem complexity
- Team familiarity
- Maintenance burden
- Performance needs

**Start simple, refactor when needed.**
