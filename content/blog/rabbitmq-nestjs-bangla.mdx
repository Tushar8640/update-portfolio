---
title: "RabbitMQ ‡¶ï‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®? NestJS ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£"
date: "2026-01-31"
description: "RabbitMQ message queue ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ application ‡¶è‡¶∞ scalability ‡¶è‡¶¨‡¶Ç reliability ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶Ø‡¶º, ‡¶ï‡¶ñ‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶è‡¶¨‡¶Ç NestJS ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá implementation ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®‡•§"
tags: ["bangla", "rabbitmq", "nestjs", "microservices", "message-queue", "backend"]
published: true
---

# RabbitMQ ‡¶ï‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®?

‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ application ‡¶Ø‡¶ñ‡¶® ‡¶¨‡¶°‡¶º ‡¶π‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡ßá, ‡¶§‡¶ñ‡¶® ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶™‡ßç‡¶∞‡¶æ‡¶Ø‡¶º‡¶á ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º - **synchronous operations** ‡¶Ø‡¶æ slow, unreliable ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§ RabbitMQ ‡¶è‡¶á ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ elegant ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡•§

## RabbitMQ ‡¶ï‡¶ø?

RabbitMQ ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø **message broker** ‡¶¨‡¶æ **message queue system**‡•§ ‡¶∏‡¶π‡¶ú ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º, ‡¶è‡¶ü‡¶ø ‡¶¶‡ßÅ‡¶á‡¶ü‡¶ø application ‡¶¨‡¶æ service ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá message pass ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø middleman‡•§

**Real-life ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:**  
‡¶ß‡¶∞‡ßÅ‡¶® ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ü‡¶æ restaurant ‡¶è order ‡¶¶‡¶ø‡¶≤‡ßá‡¶®‡•§ Waiter ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ order ‡¶®‡¶ø‡¶Ø‡¶º‡ßá kitchen ‡¶è ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶∏‡¶≤‡ßã‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá kitchen ‡¶è ‡¶¶‡¶æ‡¶Å‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá wait ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶≤‡ßã ‡¶®‡¶æ‡•§ Kitchen ‡¶Ø‡¶ñ‡¶® ready ‡¶π‡¶¨‡ßá ‡¶§‡¶ñ‡¶® serve ‡¶ï‡¶∞‡¶¨‡ßá‡•§ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá waiter ‡¶π‡¶≤‡ßã message broker (RabbitMQ)‡•§

## ‡¶ï‡ßá‡¶® RabbitMQ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®?

### 1. **Asynchronous Processing**
Heavy operations ‡¶Ø‡¶æ time ‡¶®‡ßá‡¶Ø‡¶º, ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã background ‡¶è ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶®‡•§ User instantly response ‡¶™‡¶æ‡¶¨‡ßá‡•§

### 2. **Decoupling Services**
Service ‡¶ó‡ßÅ‡¶≤‡ßã independent ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§ ‡¶è‡¶ï‡¶ü‡¶æ down ‡¶π‡¶≤‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø‡¶ü‡¶æ affected ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§

### 3. **Load Balancing**
Multiple workers ‡¶è‡¶ï‡¶á queue ‡¶•‡ßá‡¶ï‡ßá message ‡¶®‡¶ø‡¶Ø‡¶º‡ßá process ‡¶ï‡¶∞‡¶¨‡ßá‡•§ Traffic ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶≤‡ßá workers ‡¶¨‡¶æ‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶®‡•§

### 4. **Reliability**
Message lost ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§ Service crash ‡¶ï‡¶∞‡¶≤‡ßá‡¶ì message queue ‡¶§‡ßá safe ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

## ‡¶ï‡¶ñ‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®?

### Problem 1: Email/SMS ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã Slow ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡ßá

```typescript
// ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: User registration slow
async register(data: RegisterDto) {
  const user = await this.userRepo.save(data);
  
  // ‡¶è‡¶á ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ synchronous operation time ‡¶®‡¶ø‡¶ö‡ßç‡¶õ‡ßá
  await this.emailService.sendWelcomeEmail(user.email); // 2-3 sec
  await this.smsService.sendOTP(user.phone);            // 1-2 sec
  
  return user; // User 4-5 sec wait ‡¶ï‡¶∞‡¶õ‡ßá!
}
```

### Problem 2: Image/Video Processing

```typescript
// ‚ùå API timeout ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶ö‡ßç‡¶õ‡ßá
async uploadVideo(file: Express.Multer.File) {
  const uploaded = await this.s3.upload(file);
  
  // Video compress/transcode ‡¶ï‡¶∞‡¶§‡ßá 5-10 minutes!
  await this.videoService.processVideo(uploaded.url);
  
  return { message: 'Uploaded' }; // User ‡¶è‡¶§‡¶ï‡ßç‡¶∑‡¶£ wait ‡¶ï‡¶∞‡¶¨‡ßá?
}
```

### Problem 3: Microservices Communication

Order service ‡¶ï‡ßá payment service ‡¶è‡¶∞ response ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø wait ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ Network issue ‡¶π‡¶≤‡ßá fail ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡•§

## RabbitMQ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

### Architecture ‡¶¨‡ßÅ‡¶ù‡¶ø

```
Producer (API) ‚Üí RabbitMQ Queue ‚Üí Consumer (Worker)
     ‚Üì                                    ‚Üì
  Instant Response              Background Processing
```

## NestJS ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá Implementation

### Step 1: Setup ‡¶ï‡¶∞‡¶ø

```bash
npm install @nestjs/microservices amqplib amqp-connection-manager
```

### Step 2: RabbitMQ Configuration

```typescript
// rabbitmq.config.ts
export const RABBITMQ_CONFIG = {
  urls: [process.env.RABBITMQ_URL || 'amqp://localhost:5672'],
  queue: 'notifications_queue',
  queueOptions: {
    durable: true, // Server restart ‡¶π‡¶≤‡ßá‡¶ì message ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
  },
};
```

### Step 3: Producer ‡¶¨‡¶æ‡¶®‡¶æ‡¶á (‡¶Ø‡ßá message ‡¶™‡¶æ‡¶†‡¶æ‡¶¨‡ßá)

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common';
import { ClientProxy, ClientProxyFactory, Transport } from '@nestjs/microservices';
import { RABBITMQ_CONFIG } from './rabbitmq.config';

@Injectable()
export class UserService {
  private client: ClientProxy;

  constructor() {
    this.client = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: RABBITMQ_CONFIG.urls,
        queue: RABBITMQ_CONFIG.queue,
        queueOptions: RABBITMQ_CONFIG.queueOptions,
      },
    });
  }

  async register(data: RegisterDto) {
    // User save ‡¶ï‡¶∞‡¶ø - fast!
    const user = await this.userRepo.save(data);

    // Message queue ‡¶§‡ßá ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ - instant!
    this.client.emit('user.registered', {
      email: user.email,
      name: user.name,
    });

    // User instantly response ‡¶™‡ßá‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶≤‡ßã
    return { message: 'Registration successful', userId: user.id };
  }
}
```

### Step 4: Consumer ‡¶¨‡¶æ‡¶®‡¶æ‡¶á (‡¶Ø‡ßá message process ‡¶ï‡¶∞‡¶¨‡ßá)

```typescript
// notification.consumer.ts
import { Controller } from '@nestjs/common';
import { EventPattern, Payload } from '@nestjs/microservices';
import { EmailService } from './email.service';

@Controller()
export class NotificationConsumer {
  constructor(private emailService: EmailService) {}

  @EventPattern('user.registered')
  async handleUserRegistered(@Payload() data: any) {
    console.log('Processing user registration:', data);

    // Background ‡¶è email ‡¶™‡¶æ‡¶†‡¶æ‡¶ö‡ßç‡¶õ‡¶ø
    await this.emailService.sendWelcomeEmail(data.email, data.name);
    
    console.log('Welcome email sent successfully');
  }
}
```

### Step 5: Consumer App Bootstrap ‡¶ï‡¶∞‡¶ø

```typescript
// main.ts (‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ consumer service ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá run ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®)
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';
import { RABBITMQ_CONFIG } from './rabbitmq.config';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.RMQ,
      options: {
        urls: RABBITMQ_CONFIG.urls,
        queue: RABBITMQ_CONFIG.queue,
        queueOptions: RABBITMQ_CONFIG.queueOptions,
        // Multiple workers run ‡¶ï‡¶∞‡¶≤‡ßá auto load balance ‡¶π‡¶¨‡ßá
        prefetchCount: 1,
      },
    },
  );

  await app.listen();
  console.log('RabbitMQ Consumer is listening...');
}

bootstrap();
```

## Real-world Example: E-commerce Order Processing

```typescript
// order.service.ts (Producer)
@Injectable()
export class OrderService {
  constructor(
    private client: ClientProxy,
    private orderRepo: OrderRepository,
  ) {}

  async createOrder(data: CreateOrderDto) {
    // 1. Order save ‡¶ï‡¶∞‡¶ø (fast - 100ms)
    const order = await this.orderRepo.save({
      ...data,
      status: 'PENDING',
    });

    // 2. Queue ‡¶§‡ßá tasks ‡¶™‡¶æ‡¶†‡¶æ‡¶á (instant)
    this.client.emit('order.created', {
      orderId: order.id,
      userId: data.userId,
      items: data.items,
      total: data.total,
    });

    // User instantly order confirmation ‡¶™‡¶æ‡¶¨‡ßá
    return { orderId: order.id, status: 'Processing' };
  }
}

// order.consumer.ts (Consumer)
@Controller()
export class OrderConsumer {
  @EventPattern('order.created')
  async handleOrderCreated(@Payload() data: any) {
    // ‡¶è‡¶ñ‡¶® slow operations background ‡¶è
    
    // 1. Payment process ‡¶ï‡¶∞‡¶ø
    const payment = await this.paymentService.charge(data.total);
    
    // 2. Inventory update ‡¶ï‡¶∞‡¶ø
    await this.inventoryService.reduceStock(data.items);
    
    // 3. Invoice generate ‡¶ï‡¶∞‡¶ø
    const invoice = await this.invoiceService.create(data.orderId);
    
    // 4. Email ‡¶™‡¶æ‡¶†‡¶æ‡¶á
    await this.emailService.sendOrderConfirmation(data.userId, invoice);
    
    // 5. SMS ‡¶™‡¶æ‡¶†‡¶æ‡¶á
    await this.smsService.sendOrderNotification(data.userId);
    
    console.log(`Order ${data.orderId} processed successfully`);
  }
}
```

## Advanced Pattern: Request-Reply

‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá response ‡¶ö‡¶æ‡¶á‡•§ ‡¶§‡¶ñ‡¶® `send()` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßã (emit() ‡¶®‡¶Ø‡¶º):

```typescript
// Producer
async getProcessedData(userId: string) {
  // Message ‡¶™‡¶æ‡¶†‡¶æ‡¶≤‡¶æ‡¶Æ ‡¶è‡¶¨‡¶Ç response ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø wait ‡¶ï‡¶∞‡¶≤‡¶æ‡¶Æ
  const result = await this.client
    .send('process.user.data', { userId })
    .toPromise();
    
  return result;
}

// Consumer
@MessagePattern('process.user.data')
async processUserData(@Payload() data: any) {
  const processed = await this.heavyProcessing(data.userId);
  return { success: true, data: processed }; // Response return ‡¶ï‡¶∞‡¶õ‡¶ø
}
```

## Error Handling & Retry

```typescript
@EventPattern('user.registered')
async handleUserRegistered(@Payload() data: any, @Ctx() context: RmqContext) {
  try {
    await this.emailService.sendWelcomeEmail(data.email);
    
    // Success ‡¶π‡¶≤‡ßá acknowledge ‡¶ï‡¶∞‡¶ø
    const channel = context.getChannelRef();
    const originalMsg = context.getMessage();
    channel.ack(originalMsg);
    
  } catch (error) {
    console.error('Failed to send email:', error);
    
    // Failed ‡¶π‡¶≤‡ßá reject ‡¶ï‡¶∞‡¶ø - message retry ‡¶π‡¶¨‡ßá
    const channel = context.getChannelRef();
    const originalMsg = context.getMessage();
    channel.nack(originalMsg, false, true); // requeue = true
  }
}
```

## Dead Letter Queue (DLQ)

‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ fail ‡¶π‡¶ö‡ßç‡¶õ‡ßá? DLQ ‡¶§‡ßá ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡¶ø‡¶®:

```typescript
export const RABBITMQ_CONFIG = {
  urls: ['amqp://localhost:5672'],
  queue: 'notifications_queue',
  queueOptions: {
    durable: true,
    arguments: {
      'x-dead-letter-exchange': 'dlx',
      'x-dead-letter-routing-key': 'failed_notifications',
      'x-message-ttl': 60000, // 1 minute retry
    },
  },
};
```

## Multiple Queues ‡¶™‡¶∞‡¶ø‡¶ö‡¶æ‡¶≤‡¶®‡¶æ

```typescript
// app.module.ts
@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'EMAIL_SERVICE',
        transport: Transport.RMQ,
        options: {
          urls: ['amqp://localhost:5672'],
          queue: 'email_queue',
        },
      },
      {
        name: 'SMS_SERVICE',
        transport: Transport.RMQ,
        options: {
          urls: ['amqp://localhost:5672'],
          queue: 'sms_queue',
        },
      },
    ]),
  ],
})
export class AppModule {}

// Service ‡¶è inject ‡¶ï‡¶∞‡¶ø
constructor(
  @Inject('EMAIL_SERVICE') private emailClient: ClientProxy,
  @Inject('SMS_SERVICE') private smsClient: ClientProxy,
) {}
```

## Performance Tips

### 1. Prefetch Count ‡¶∏‡¶†‡¶ø‡¶ï ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®
```typescript
options: {
  prefetchCount: 10, // ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá 10‡¶ü‡¶æ message ‡¶®‡¶ø‡¶¨‡ßá
}
```

### 2. Connection Pooling
```typescript
import { connect } from 'amqp-connection-manager';

const connection = connect(['amqp://localhost:5672'], {
  heartbeatIntervalInSeconds: 30,
  reconnectTimeInSeconds: 5,
});
```

### 3. Message Priority
```typescript
this.client.emit('high.priority.task', data, {
  priority: 10, // 0-10, higher = more priority
});
```

## ‡¶ï‡¶ñ‡¶® RabbitMQ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ?

1. **Simple CRUD apps** - Over-engineering ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ
2. **Real-time requirements** - WebSocket ‡¶¨‡ßá‡¶ü‡¶æ‡¶∞ (chat apps)
3. **Small traffic** - ‡¶è‡¶§ complexity ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‡¶®‡¶æ
4. **Strong consistency needed** - Direct database transaction ‡¶≠‡¶æ‡¶≤‡ßã

## ‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ vs ‡¶Ö‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ

### ‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ
- ‚ö° Fast API responses
- üìà Scalable (workers ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶®)
- üîÑ Reliable (message lost ‡¶π‡¶Ø‡¶º ‡¶®‡¶æ)
- üîå Decoupled services
- üõ°Ô∏è Fault tolerant

### ‡¶Ö‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ
- üèóÔ∏è Extra infrastructure (RabbitMQ server ‡¶ö‡¶æ‡¶≤‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá)
- üß† Learning curve ‡¶Ü‡¶õ‡ßá
- üêõ Debugging complex ‡¶π‡¶Ø‡¶º (distributed system)
- üí∞ Cost ‡¶¨‡¶æ‡¶°‡¶º‡ßá (server, maintenance)

## Production Checklist

- ‚úÖ RabbitMQ cluster setup ‡¶ï‡¶∞‡ßÅ‡¶® (high availability)
- ‚úÖ Monitoring setup ‡¶ï‡¶∞‡ßÅ‡¶® (RabbitMQ Management UI)
- ‚úÖ Dead Letter Queue configure ‡¶ï‡¶∞‡ßÅ‡¶®
- ‚úÖ Message persistence enable ‡¶ï‡¶∞‡ßÅ‡¶®
- ‚úÖ Connection retry logic add ‡¶ï‡¶∞‡ßÅ‡¶®
- ‚úÖ Proper error logging ‡¶ï‡¶∞‡ßÅ‡¶®
- ‚úÖ Load testing ‡¶ï‡¶∞‡ßÅ‡¶®

## ‡¶∂‡ßá‡¶∑ ‡¶ï‡¶•‡¶æ

RabbitMQ ‡¶è‡¶ï‡¶ü‡¶æ powerful tool ‡¶Ø‡¶æ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá application ‡¶è‡¶∞ performance ‡¶è‡¶¨‡¶Ç reliability ‡¶Ö‡¶®‡ßá‡¶ï ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶Ø‡¶º‡•§ ‡¶§‡¶¨‡ßá ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶¨‡ßá‡¶®:

> "Use it when you need it, not because it's cool."

‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ application ‡¶è‡¶∞ requirements ‡¶¨‡ßÅ‡¶ù‡ßÅ‡¶®, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ decide ‡¶ï‡¶∞‡ßÅ‡¶® RabbitMQ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‡¶ï‡¶ø‡¶®‡¶æ‡•§ ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá simple ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®, scale ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶™‡¶°‡¶º‡¶≤‡ßá ‡¶§‡¶ñ‡¶® add ‡¶ï‡¶∞‡ßÅ‡¶®‡•§

Happy coding! üöÄ
